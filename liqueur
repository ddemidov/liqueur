#!/usr/bin/python

#----------------------------------------------------------------------------
# Configuration
#----------------------------------------------------------------------------
# Nodes with load_avg above this will not be shutdown.
load_tol = 0.4

# Broadcast address for sending wake-on-lan packet.
ifaddr   = "192.168.29.255"

# MAC-addresses of computing nodes.
macaddr  = {
    "node1" : "20:cf:30:e4:1c:e3",
    "node2" : "20:cf:30:4c:dc:6d",
    "node3" : "20:cf:30:e4:1e:99",
    "node4" : "20:cf:30:e4:1e:89",
    }

# Interval in seconds between status updates.
sleepfor = 60

# For a node to be shutdown it has to be idle for this number of intervals
# in a row. So if sleepfor == 60 and max_idle == 20, node has to be idle
# for 20 minutes before it goes down.
max_idle = 20

# List of nodes is pulled from gridengine via qhost command. Liqueur only
# manages nodes with names matching this pattern.
node_name_pattern = 'node.*'

#----------------------------------------------------------------------------
# Code
#----------------------------------------------------------------------------
import re, subprocess, time
from lxml   import etree
from syslog import syslog

node_name = re.compile(node_name_pattern)

class Host:
    def __init__(self, name):
	self.name = name
	self.jobs = 0
	self.load = 0
	self.idle = 0
	self.cpus = 0

    # Wakes the node up. Returns number of processors on the node.
    def wakeup(self):
	if self.load == '-':
	    if self.name in macaddr:
		syslog("Waking %s up" % h)
		subprocess.Popen(['wol', '-i', ifaddr, macaddr[self.name]])
		self.idle = 0
		return int(self.cpus)
	    else:
		syslog("%s has no mac-address")
	return 0

    # Shuts the node down.
    def shutdown(self):
	if self.load != '-':
	    if int(self.jobs) == 0:
		self.idle += 1
		if self.idle > max_idle and float(self.load) < load_tol:
		    syslog("Shutting %s down" % self.name)
		    subprocess.Popen(['ssh', self.name, 'poweroff'])
	    else:
		self.idle = 0

hosts = {}

while True:
    # Parse output of qstat and qhost
    qhost = etree.fromstring(subprocess.check_output(['qhost', '-q', '-xml']))
    qstat = etree.fromstring(subprocess.check_output(
	['qstat', '-s', 'p', '-u', '*', '-xml']))

    # Get number of pending slots
    pending_slots = sum([int(j.findtext('slots'))
	for j in qstat.findall('job_info/job_list')
	])

    # Get host list
    for h in qhost.findall('host'):
	name = h.get('name')
	if not node_name.match(name): continue

	if name not in hosts: hosts[name] = Host(name)

	hosts[name].load = h.findtext("hostvalue[@name='load_avg']")
	hosts[name].jobs = h.findtext("queue/queuevalue[@name='slots_used']")
	hosts[name].cpus = h.findtext("hostvalue[@name='num_proc']")

    # Analyze queue status
    if pending_slots > 0:
	# Wake up!
	for h in hosts:
	    pending_slots -= hosts[h].wakeup()
	    if pending_slots <= 0: break
    else:
	# Shut someone down?
	for h in hosts: hosts[h].shutdown()

    time.sleep(sleepfor)
